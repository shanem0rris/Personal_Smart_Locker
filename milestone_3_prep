#include <EEPROM.h>
#define NUM_ROWS 4
#define NUM_COLS 3

//Keypad layout
const char KEYS[NUM_ROWS][NUM_COLS] = {
  {'1','2','3'},
  {'4','5','6'},
  {'7','8','9'},
  {'*','0','#'}
};

//Keypad Pin mapping
const uint8_t rowPins[NUM_ROWS] = {8, 2, 3, 4};
const uint8_t colPins[NUM_COLS] = {5, 6, 7};

//EEPROM layout - 0xAA indicates that password is set and the next 4 bytes read in should be the password
const int ADDR_FLAG = 0;
const int ADDR_PASSWORD = 1;
const uint8_t INIT_FLAG = 0xAA;
const int PASS_LENGTH = 4;

char entered[PASS_LENGTH + 1];
char stored[PASS_LENGTH + 1];

bool password = false;

//analog setup
const int analogPin = A0;

//main
void setup(){
  Serial.begin(9600);
  while (!Serial){ ; }

  //configures row pins to output and idle high
  for(int r = 0; r < NUM_ROWS; ++r){
    pinMode(rowPins[r], OUTPUT);
    digitalWrite(rowPins[r], HIGH);
  }

  //configures column pins to be Inputs w/ Pullup Resistor
  for(int c = 0; c < NUM_COLS; ++c){
    pinMode(colPins[c], INPUT_PULLUP);
  }

  //setup servo pin
  pinMode(9, OUTPUT);

  Serial.println();
  Serial.println("---Keypad Password System---");

  //if password has never been set, set one for the first time and save it to memory
  if(!isPasswordSet()){
    Serial.println("No saved password found. Enter initial 4-digit password:");
    //reads and saves password
    readPasswordFromKeypad(entered);
    writePasswordToEEPROM(entered);
    Serial.print("Initial password saved: ");
    Serial.println(mask(entered));
    Serial.println("System is now locked.");
    password = false;
    setServoAngle(-90);  // lock servo initially
    delay(500);
  } else {
    //read stored password
    readPasswordFromEEPROM(stored);
    Serial.println("Password loaded from memory.");
    password = false;
    setServoAngle(-90);  // lock servo initially
  }
}

void loop() {
  Serial.println();
  Serial.println("Locked. Please enter 4-digit password:");
  readPasswordFromKeypad(entered);

  //read password in from keypad and check against stored value
  //if correct -> unlock, if incorrect -> stay locked
  if(comparePasswords(entered, stored)){
    Serial.println("Correct! System unlocked.");
    password = true;
    setServoAngle(90);   // unlock servo
    unlockedMenu();
  } else {
    Serial.println("Incorrect password.");
    password = false;
    setServoAngle(-90);  // keep locked
    //delay to prevent spam
    delay(500);
  }
}

//HELPER FUNCTIONS

char getKey(){
  // For each row: drive it LOW, others HIGH, then sample columns
  for(int r = 0; r < NUM_ROWS; ++r){
    // set all rows HIGH (idle)
    for(int i = 0; i < NUM_ROWS; ++i) digitalWrite(rowPins[i], HIGH);
    // drive current row LOW
    digitalWrite(rowPins[r], LOW);
    delay(3); // small settle time


    for(int c = 0; c < NUM_COLS; ++c) {
      if(digitalRead(colPins[c]) == LOW) { // active LOW when key pressed
        // debounce: simple stable-read
        delay(20);
        if(digitalRead(colPins[c]) == LOW) {
          // wait until key released to avoid repeats
          while(digitalRead(colPins[c]) == LOW) {
            delay(5);
          }
          delay(10); // post-release debounce
          return KEYS[r][c];
        }
      }
    }
  }
  return 0;
}

char getKeyAnalog() {
  int sensorValue = analogRead(A0);
  if (sensorValue < 400) return 0;

  char key = 0;
  if (sensorValue > 800){
    key = '1';
  } else if (sensorValue > 750){
    key = '2';
  } else if (sensorValue > 700){
    key = '3';
  } else if (sensorValue > 670){
    key = '4';
  } else if (sensorValue > 630){
    key = '5';
  } else if (sensorValue > 580){
    key = '6';
  } else if (sensorValue > 540){
    key = '7';
  } else if (sensorValue > 515){
    key = '8';
  } else if (sensorValue > 480){
    key = '9';
  } else if (sensorValue > 455){
    key = '*';
  } else if (sensorValue > 435){
    key = '0';
  } else if (sensorValue > 421) key = '#';

  if (key != 0) {
    delay(30);
    while (analogRead(A0) > 400) {
      delay(10);
    }
  }

  return key;
}


void readPasswordFromKeypad(char *buf) {
  int idx = 0;
  //set the buffer address to receive memory
  memset(buf, 0, PASS_LENGTH + 1);

  while(idx < PASS_LENGTH){
    char k = getKeyAnalog();
    //read in a key press, and only fill the memory if its a number
    if(k){
      if(k >= '0' && k <= '9') {
        buf[idx++] = k;
        Serial.print('*');
        //show messages for ignored keys
      } else{
        if(k == '*') Serial.print("*");
        if(k == '#') Serial.print("#");
      }
    }
    //prevent spam
    delay(10);
  }
  Serial.println();
  //null terminate
  buf[PASS_LENGTH] = '\0';
}

//EEPROM Helpers

//check if password is set by looking at initialization flag comparison
bool isPasswordSet(){
  return (EEPROM.read(ADDR_FLAG) == INIT_FLAG);
}

//write initialization flag to ADDR_FLAG
void writeFlag(){
  EEPROM.write(ADDR_FLAG, INIT_FLAG);
}

//writes password to EEPROM memory using pointer
void writePasswordToEEPROM(const char *p){
  for(int i = 0; i < PASS_LENGTH; ++i){
    EEPROM.write(ADDR_PASSWORD + i, (uint8_t)p[i]);
    stored[i] = p[i];
  }
  //null terminate
  stored[PASS_LENGTH] = '\0';
  writeFlag();
}

//reads password into pointer from EEPROM
void readPasswordFromEEPROM(char *outBuf){
  for(int i = 0; i < PASS_LENGTH; ++i){
    char v = (char)EEPROM.read(ADDR_PASSWORD + i);
    if(v < '0' || v > '9') v = '0';
    outBuf[i] = v;
  }
  //null terminate
  outBuf[PASS_LENGTH] = '\0';
  for(int i = 0; i <= PASS_LENGTH; ++i) stored[i] = outBuf[i];
}

//UI Functions

//compare the two passed passwords
bool comparePasswords(const char *a, const char *b){
  for(int i = 0; i < PASS_LENGTH; ++i){
    if(a[i] != b[i]) return false;
  }
  return true;
}

//provide options to change password or relock system
void unlockedMenu(){
  Serial.println("Options: Press '*' to change password, or '#' to lock again.");
  unsigned long start = millis();
  const unsigned long waitMs = 15000UL;

  char opt = 0;
  while((millis() - start) < waitMs && opt == 0){
    char k = getKeyAnalog();
    if (k){
      if(k == '*') opt = '*';
      else if(k == '#') opt = '#';
    }
    delay(10);
  }
  //enter change or lock mode depending on input
  if(opt == '*'){
    Serial.println("Enter new 4-digit password:");
    readPasswordFromKeypad(entered);
    writePasswordToEEPROM(entered);
    Serial.print("New password saved: ");
    Serial.println(mask(entered));
    Serial.println("System relocking after password change.");
    password = false;
    setServoAngle(-90);  // relock servo automatically
  } else {
    Serial.println("Locking system again.");
    password = false;
    setServoAngle(-90);  // relock servo
  }
}

String mask(const char *p){
  (void)p; // p unused â€” we always mask
  String s = "";
  for (int i = 0; i < PASS_LENGTH; ++i) s += '*';
  return s;
}

void setServoAngle(int servoAngle)
{
  int pwm;
  pwm = map(servoAngle, 0, 180, 1000, 2000);
  for (int i = 0; i < 50; i++)
  {
    PORTB |= (1 << 1); // replacement for digitalWrite(servoPin, HIGH);
    delayMicroseconds(pwm);
    PORTB &= ~(1 << 1); // replacement for digitalWrite(servoPin, LOW);
    delayMicroseconds(20000 - pwm);
  }
}
